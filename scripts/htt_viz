#!/usr/bin/env python3

import sys
import yaml

import rospy
from htt_viz.srv import Update
from htt_viz.srv import UpdateResponse

from htt_viz_py.QGraphicsTaskTreeNode import QGraphicsTaskTreeNode
from htt_viz_py.tree import Tree
from htt_viz_py.imgout import makeImg
from htt_viz_py.orgButton import organizeTreeButton

from PyQt5 import QtCore, QtWidgets, QtGui
from PyQt5.QtWidgets import QMainWindow, QWidget, QPushButton, QAction, QFrame
from PyQt5.QtCore import QSize, Qt	
from PyQt5.QtGui import QIcon
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5 import uic

class MainWindow(QMainWindow):
	def __init__(self):
		QMainWindow.__init__(self)
		self.initUI()		
		
		#This is a placeholder for now as the actual tree isn't used however once it is it should be good
		#to go just by uncommenting it and the ros functionality will go back to normal
		self.server = rospy.Service('update_htt', Update, self.taskTree.updateCallback)


	def initUI(self):
		#self.waiting = True

		self.setMinimumSize(QSize(350, 275)) 
		self.resize(700, 550)   
		self.setWindowTitle("HTT-Viz")
		#self.setWindowIcon(QIcon("src/htt-viz/data/Capture.ico"))

		# New Action
		newAction = QAction(QIcon('new.png'), '&New', self)		
		newAction.setShortcut('Ctrl+N')
		newAction.setStatusTip('New document')
		newAction.triggered.connect(self.newCall)

		# Open Action
		openAction = QAction(QIcon('open.png'), '&Open', self)		
		openAction.setShortcut('Ctrl+O')
		openAction.setStatusTip('Open document')
		openAction.triggered.connect(self.openCall)
		
		# Save Action
		saveAction = QAction(QIcon('save.png'), '&Save', self)		
		saveAction.setShortcut('Ctrl+S')
		saveAction.setStatusTip('Save document')
		saveAction.triggered.connect(self.saveCall)
		
		# Save As Action
		saveAsAction = QAction(QIcon('saveas.png'), '&Save As...', self)		
		saveAsAction.setShortcut('Ctrl+Shift+S')
		saveAsAction.setStatusTip('Save document as...')
		saveAsAction.triggered.connect(self.saveAsCall)
	
		# Exit Action
		exitAction = QAction(QIcon('exit.png'), '&Exit', self)		
		exitAction.setShortcut('Ctrl+Q')
		exitAction.setStatusTip('Exit application')
		exitAction.triggered.connect(self.exitCall)
		
		# Undo Action
		undoAction = QAction(QIcon('undo.png'), '&Undo', self)		
		undoAction.setShortcut('Ctrl+Z')
		undoAction.setStatusTip('Undo previous action')
		undoAction.triggered.connect(self.undoCall)
		
		# Redo Action
		redoAction = QAction(QIcon('redo.png'), '&Redo', self)		
		redoAction.setShortcut('Ctrl+Shift+Z')
		redoAction.setStatusTip('Redo previously undone action')
		redoAction.triggered.connect(self.redoCall)
		
		# Settings Action
		settingsAction = QAction(QIcon('settings.png'), '&Settings', self)
		settingsAction.setStatusTip('View the settings')
		settingsAction.triggered.connect(self.settingsCall)
		
		# About Action
		aboutAction = QAction(QIcon('about.png'), '&About', self)
		aboutAction.setStatusTip('View the about window')
		aboutAction.triggered.connect(self.aboutCall)

		# Create menu bar and add actions
		menuBar = self.menuBar()
		
		fileMenu = menuBar.addMenu('&File')
		fileMenu.addAction(newAction)
		fileMenu.addAction(openAction)
		fileMenu.addAction(saveAction)
		fileMenu.addAction(saveAsAction)
		fileMenu.addSeparator()
		fileMenu.addAction(exitAction)
		
		editMenu = menuBar.addMenu('&Edit')
		editMenu.addAction(undoAction)
		editMenu.addAction(redoAction)
		
		viewMenu = menuBar.addMenu('&View')
		viewMenu.addAction(settingsAction)
		
		helpMenu = menuBar.addMenu('&Help')
		helpMenu.addAction(aboutAction)
		
		# Splitter
		self.subWindow1 = SubWindow()
		self.subWindow2 = SubWindow()
		
		self.subsplitter = QSplitter(Qt.Horizontal)
		self.subsplitter.setStyleSheet('background-color: rgb(50,50,50)') 
		self.subsplitter.addWidget(self.subWindow1)
		self.subsplitter.addWidget(self.subWindow2)
		
		#Add Place For Buttons Above Tree Display
		self.buttonRack = ButtonRack()
		self.subWindow2.layout().addWidget(self.buttonRack, alignment=QtCore.Qt.AlignRight)
		
		#Create Organize Tree Button
		orgButton = QPushButton(self)
		orgButton.setText("Organize Tree")
		orgButton.setStyleSheet("background-color:lightGray")
		orgButton.clicked.connect(lambda : organizeTreeButton.organizeTree(organizeTreeButton, self.taskTree.root_node))
		
		#Create Img Export Button
		imgButton = QPushButton(self)
		imgButton.setText("Export PNG")
		imgButton.setStyleSheet("background-color:lightGray")
		imgButton.clicked.connect(lambda : makeImg(self.taskTree.root_node, self))
		
		#Add Buttons to Button Rack
		self.buttonRack.addButton(orgButton)
		self.buttonRack.addButton(imgButton)
		
		# Setup Task Tree Display
		self.taskTree = Tree()
		self.taskTreeDisplayWidget = HTTDisplayWidget(self.taskTree, self)
		self.subWindow2.layout().addWidget(self.taskTreeDisplayWidget)
		
		self.nodeList = QListWidget()
		self.subWindow1.layout().addWidget(self.nodeList)
		
		for nodeType in self.taskTree.author.node_master_list[1:]:
			self.nodeList.addItem(nodeType.name)
		
		self.nodeList.itemSelectionChanged.connect(self.handleNodeSelectionChange)
		self.nodeList.item(0).setSelected(True)
		self.subWindow1.setMaximumWidth(150)
		
		self.setCentralWidget(self.subsplitter)
		
		self.filePath = None

		
		
	def handleNodeSelectionChange(self):
		selectedItem = self.nodeList.selectedItems()[0]

		# We only use 1 column. 
		# index is incremented by 1 as root is removed from QListWidget
		self.taskTreeDisplayWidget.selectedNodeIndex = self.nodeList.row(selectedItem) + 1

	def openCall(self):
		options = QFileDialog.Options()
		options |= QFileDialog.DontUseNativeDialog
		filePath, _ = QFileDialog.getOpenFileName(self, "Open", "","YAML Files (*.yaml)", options=options)
		if filePath:
			self.filePath = filePath
			
			with open(filePath, "r") as f:
				data = yaml.load(f, Loader=yaml.Loader)
				
				self.taskTreeDisplayWidget.clearTaskTree()

				#clear all the currently loaded behaviors
				self.taskTree.author.clearTypes()

				#load all the behavior types that are needed for the file we are opening
				for file_name in data["NodeFileIncludes"]:
					try: # TODO Catch FileNotFoundError to notify user
						self.taskTree.author.addNodeFromFile(file_name)
					except FileNotFoundError:
						sys.exit("Hey Nathaniel, I give up. Also line 194 - Brady <3")
						#self.w = FileNotFoundWindow(self)
						#self.w.show()
						#self.waiting = True
						#while self.waiting:
							#pass


				# I'm leaving this in just because it is helpful for debugging
				# print(self.taskTree.author.toString())
				
				for node in data["NodeList"]:
					#name, x=0, y=0, nParent = None
					x = data["Nodes"][node]["x"]
					y = data["Nodes"][node]["y"]
					parent = data["Nodes"][node]["parent"]

					node_type = data["Nodes"][node]["mask"]["type"]
					
					self.taskTreeDisplayWidget.addChildNodeFromDict(data["Nodes"][node])

					#now that the node has been added to the tree I have to fill in its parameters
					node_ptr = self.taskTree.findNodeByName(node)
					for param in node_ptr.params:
						param.value = data["Nodes"][node][param.name]

					if "Title" in data["Nodes"][node]:
						node_ptr.setTitle(data["Nodes"][node]["Title"]) # Unhappy Path :(

		self.setWindowTitle("HTT-Viz")

	def newCall(self):
		self.filePath = None

	# https://pythonspot.com/pyqt5-file-dialog/	
	def saveCall(self):

		if not self.filePath:
			dialog = QFileDialog()
			dialog.setFilter(dialog.filter() | QtCore.QDir.Hidden)
			dialog.setDefaultSuffix('yaml')
			dialog.setAcceptMode(QFileDialog.AcceptSave)
			dialog.setNameFilters(['YAML (*.yaml)'])
			if dialog.exec_() != QDialog.Accepted:
				return

			self.filePath = dialog.selectedFiles()[0]
			
		filePath = self.filePath
		
		#if not filePath:
		#	options = QFileDialog.Options()
		#	options |= QFileDialog.DontUseNativeDialog
		#	filePath, _ = QFileDialog.getSaveFileName(self,"Save","","YAML Files (*.yaml)", options=options)
		#	if not filePath:
		#		return
		#	self.filePath = filePath
			
		data = self.taskTree.toYamlDict()
		with open(filePath, "w") as f:
			yaml.dump(data, f)
			
		self.setWindowTitle("HTT-Viz")
		
	def saveAsCall(self): # Catching NULL pointers in java, a sign of deeper problems.
		dialog = QFileDialog()
		dialog.setFilter(dialog.filter() | QtCore.QDir.Hidden)
		dialog.setDefaultSuffix('yaml')
		dialog.setAcceptMode(QFileDialog.AcceptSave)
		dialog.setNameFilters(['YAML (*.yaml)'])
		if dialog.exec_() != QDialog.Accepted:
			return

		#options = QFileDialog.Options()
		#options |= QFileDialog.DontUseNativeDialog
		#filePath, _ = QFileDialog.getSaveFileName(self, "Save As","","YAML Files (*.yaml)", options=options)
		
		self.filePath = dialog.selectedFiles()[0]
			
		data = self.taskTree.toYamlDict()
		with open(self.filePath, "w") as f:
			yaml.dump(data, f)
				
		self.setWindowTitle("HTT-Viz")

	def exitCall(self):
		self.close()
		
	def undoCall(self):
		#print('undo')
		obj = self.taskTree.undo_stack.pop()

		if not obj is None:
			obj.run()
			obj.switch = False
			obj.next = None
			self.taskTree.redo_stack.push(obj)

		#self.taskTree.Refresh(False)

	def redoCall(self):
		#print('redo')
		obj = self.taskTree.redo_stack.pop()

		if not obj is None:
			obj.run()
			obj.switch = True
			obj.next = None 
			self.taskTree.undo_stack.push(obj)

		#self.taskTree.Refresh(False)
		
		
	def settingsCall(self):
		self.w = SettingsWindow(self)
		self.w.show()
		
	def aboutCall(self):
		msg = QMessageBox()
		msg.setIcon(QMessageBox.Information)
		msg.setText("HTT-Viz About...")
		msg.setWindowTitle("HTT-Viz About")
		
		msg.exec()

	def closeEvent(self, event):
		if self.windowTitle() == "HTT-Viz":
			event.accept()
		else:
			event.ignore()
			self.w = UnsavedContentWindow(self)
			self.w.show()

class SubWindow(QWidget):
	def __init__(self):
		super(SubWindow, self).__init__()

		self.main_layout = QVBoxLayout()
		self.setLayout(self.main_layout)
		
class ButtonRack(QWidget):
	def __init__(self):
		super().__init__()
		self.layout = QHBoxLayout()
		self.setLayout(self.layout)
		
	def addButton(self, QPushButton):
		self.layout.addWidget(QPushButton, alignment=QtCore.Qt.AlignRight)

class HTTDisplayWidget(QGraphicsView):
	def __init__(self, taskTree, mainWin):
		super().__init__()
		self.mainWin = mainWin
		
		self.taskTree = taskTree
		self.scene = QGraphicsScene()
		self.scene.setBackgroundBrush(QColor(0x3D, 0x3D, 0x3D))
		self.setScene(self.scene)
		self.taskTree.registerScene(self.scene)
		
		# TODO: Scrolling makes a constant cursor, and feels really janky to use
		# Maybe we should implment our own?
		# QGraphicsView.DragMode.ScrollHandDrag = 1
		self.setDragMode(1)
		
		self.show()
		
		self.selectedNodeIndex = 0
		
	def addChildNode(self, parentName, selectedNodeIndex, x=None, y=None):
		parentNode = self.taskTree.findNodeByName(parentName)
		if parentNode is not None:
			if not self.tooManyRootChildren(parentNode):			
				self.taskTree.addNode([parentNode, selectedNodeIndex, True])
				self.localSort(parentNode)
				#organizeTreeButton.organizeTree(organizeTreeButton, self.taskTree.root_node)
			
		self.mainWin.setWindowTitle("*HTT-Viz")

	def replaceTree(self):
		self.taskTreeDisplayWidget.clearTaskTree()
		self.taskTree.replaceRootNode(self.scene)

	def addChildNodeFromDict(self, dict):
		self.taskTree.addChildNodeFromDict(dict)
				
	def removeChildNode(self, name):
		self.taskTree.removeNode([name, True])
		
		self.mainWin.setWindowTitle("*HTT-Viz")
				
	def clearTaskTree(self):
		#for child in self.taskTree.root_node.children:
		#	self.removeChildNode(child.name)
		self.taskTree.destroyTree()

	def mouseDoubleClickEvent(self, event):
		eventPos = event.pos()
		maybeNode = self.itemAt(eventPos)
		if not isinstance(maybeNode, QGraphicsTaskTreeNode):
			maybeNode = None

		if maybeNode is not None:
			#print('Edit Node')
			self.w = EditWindow(self.taskTree.findNodeByName(maybeNode.name), self.mainWin)
			self.w.show()
		
	def contextMenuEvent(self, event):
		eventPos = event.pos()
		maybeNode = self.itemAt(eventPos)
		if not isinstance(maybeNode, QGraphicsTaskTreeNode):
			maybeNode = None
	
		# https://stackoverflow.com/questions/67591464/create-event-clicking-on-context-menu-with-python-pyqt5
		menu = QMenu(self)
		# TODO: Only show items if a node was selected, else early exit or show different menu
		addChildNode = menu.addAction("Add Child Node")
		editNode = menu.addAction("Edit Node")
		removeNode = menu.addAction("Remove Node")
		close = menu.addAction("Close")
		action = menu.exec_(self.mapToGlobal(eventPos))
		
		if action == addChildNode:
			if maybeNode is not None:
				self.addChildNode(maybeNode.name, self.selectedNodeIndex)
		elif action == editNode:
			if maybeNode is not None:
				#print('Edit Node')
				self.w = EditWindow(self.taskTree.findNodeByName(maybeNode.name), self.mainWin)
				self.w.show()
		elif action == removeNode:
			if maybeNode is not None:
				self.removeChildNode(maybeNode.name)
		elif action == close:
			if self.windowTitle() != "HTT-Viz":
				self.w = UnsavedContentWindow(self.mainWin)
				self.w.show()
			else:   
				app.quit()
		else:
			print('Unknown Action:')
			print(action)
			
	def tooManyRootChildren(self, parentNode):
		if parentNode.isRoot():
			if len(parentNode.children) > 0:
				self.w = TooManyRootChildrenErrorWindow(self)
				self.w.show()
				return True
			else:
				return False
		else:
			return False
			
	def localSort(self, parentNode):
		if len(parentNode.children) == 1:
			for child in parentNode.children:
				child.setX(parentNode.getX())
				child.setY(parentNode.getY() + 80)
				
		else:
			max = float('-inf')
			for child in parentNode.children:
				child.setY(parentNode.getY() + 80)
				if child.getX() > max:
					max = child.getX()
					
			lastChild = len(parentNode.children) - 1
			parentNode.children[lastChild].setX((parentNode.children[lastChild - 1].getX() + (parentNode.children[lastChild].getWidth() * 1.5)))
			difference = (parentNode.children[lastChild].getWidth() * 1.5)/2
			for child in parentNode.children:
				organizeTreeButton.moveSubTree(organizeTreeButton, child, difference)

			
class EditWindow(QDialog):
	def __init__(self, node, mainWin):
		super().__init__()

		self.setWindowModality(Qt.ApplicationModal)

		self.node = node
		self.mainWin = mainWin
		
		textBoxList = QFormLayout()
		
		p = self.palette()
		p.setColor(self.backgroundRole(), QColor(0x3D, 0x3D, 0x3D))
		self.setPalette(p)
		
		self.setWindowTitle(node.name)
		self.setMinimumSize(QSize(350, 275)) 
		self.resize(350, 275)
		
		self.titleBox = QLineEdit()
		self.titleBox.setMaxLength(16)
		self.titleBox.resize(200,40)
		self.titleBox.setText(node.title)
		#print(node.title)
		textBoxList.addRow("Title", self.titleBox)
		
		#self.paramBox = QPlainTextEdit()
		#self.paramBox.resize(200,120)
		#self.paramBox.setPlainText("Node Params") #NEEDS BACKEND
		#textBoxList.addRow("Parameters", self.paramBox)
		
		#CHANGE TO FOREACH FOR PARAMETER ARRAY BASED ON TYPE
		
		self.paramList = []
		for x in node.params:
			param = None
			
			if x.type == "bool":
				param = QCheckBox()
				param.setChecked(x.value)
			elif x.type == "float":
				param = QLineEdit()
				param.setValidator(QDoubleValidator(0.99,99.99,2))
				param.setText(str(x.value))
			elif x.type == "int":
				param = QLineEdit()
				param.setValidator(QIntValidator())
				param.setText(str(x.value))
			elif x.type == "string":
				param = QLineEdit()
				#param.setValidator(QStrValidator())
				param.setText(str(x.value))
			else:
				#sys.exit()
				print('Unsupported Parameter')
					
			self.paramList.append(param)
			textBoxList.addRow(x.name, param)
			param.textChanged.connect(self.onChange)
		
		saveButton = QPushButton('Save', self)
		saveButton.clicked.connect(self.saveClick)
		
		closeButton = QPushButton('Close', self)
		closeButton.clicked.connect(self.closeClick)
		
		textBoxList.addRow(saveButton, closeButton)
		
		self.setLayout(textBoxList)
		
		self.titleBox.textChanged.connect(self.onChange)
		#self.paramBox.textChanged.connect(self.onChange)

	def onChange(self):
		self.setWindowTitle("*"+self.node.name)
		
	def saveClick(self):
		#save parameter values
		self.node.setTitle(self.titleBox.text())

		#save the actual values of the parameter as well here
		for i in range(len(self.paramList)):
			if self.node.params[i].type == "bool":
				self.node.params[i].setValue(self.paramList[i].isChecked())
			else:
				self.node.params[i].setValue(self.paramList[i].text())
				
		self.mainWin.setWindowTitle("*HTT-Viz")
		self.setWindowTitle(self.node.name)
		
	def closeClick(self):
		if self.windowTitle() != self.node.name:
			self.w = UnsavedContentWindow(self)
			self.w.show()
			#self.setUpdatesEnabled(False)
		else:	
			self.close()

class UnsavedContentWindow(QDialog): # Try to change to QMessageBox or QErrorBox
	def __init__(self, window):
		super().__init__()

		self.setWindowModality(Qt.ApplicationModal)

		self.window = window

		p = self.palette()
		p.setColor(self.backgroundRole(), QColor(0x3D, 0x3D, 0x3D))
		self.setPalette(p)
		
		self.setWindowTitle("Warning!")
		self.setMinimumSize(QSize(225, 130))
		self.setMaximumSize(QSize(225, 130)) 
		self.resize(225, 130)

		uC = QLabel()
		uC.setText("Unsaved Content")
		uC.setStyleSheet("color: white")
		uC.setAlignment(Qt.AlignCenter)

		vbox = QVBoxLayout()
		vbox.addWidget(uC)

		saveButton = QPushButton('Save Content', self)
		#saveButton.move(5, 80)
		saveButton.clicked.connect(self.saveContentClick)
		vbox.addWidget(saveButton)

		if window.windowTitle() == "*HTT-Viz":
			saveAsButton = QPushButton('Save Content As', self)
			saveAsButton.clicked.connect(self.saveContentAsClick)
			vbox.addWidget(saveAsButton)
		
		closeButton = QPushButton('Close Anyway', self)
		#closeButton.move(120, 80)
		closeButton.clicked.connect(self.closeAnywayClick)
		vbox.addWidget(closeButton)

		
		
		self.setLayout(vbox)

	def saveContentClick(self):
		#save parameter values
		if self.window.windowTitle() == "*HTT-Viz":
			self.window.saveCall()
			self.close()
		elif self.window.windowTitle() == ("*"+self.window.node.name):
			self.window.saveClick()
			self.close()
		
	def saveContentAsClick(self):
		self.window.saveAsCall()
		self.close()

	def closeAnywayClick(self):
			#self.window.close()
		if self.window.windowTitle() == "*HTT-Viz":
			app.quit()
		elif self.window.windowTitle() == ("*"+self.window.node.name):
			self.window.close()
			self.close()

	#def closeEvent(self, event):
		#self.window.setUpdatesEnabled(True)

class FileNotFoundWindow(QDialog):
	def __init__(self, window):
		super().__init__()

		self.setWindowModality(Qt.ApplicationModal)

		self.window = window

		p = self.palette()
		p.setColor(self.backgroundRole(), QColor(0x3D, 0x3D, 0x3D))
		self.setPalette(p)
		
		self.setWindowTitle("File Not Found!!")
		self.setMinimumSize(QSize(225, 130))
		self.setMaximumSize(QSize(225, 130)) 
		self.resize(225, 130)

	#def closeEvent(self, event):
		#self.window.waiting = False

class TooManyRootChildrenErrorWindow(QDialog):
	def __init__(self, window):
		super().__init__()

		self.setWindowModality(Qt.ApplicationModal)

		self.window = window
		
		p = self.palette()
		p.setColor(self.backgroundRole(), QColor(0x3D, 0x3D, 0x3D))
		self.setPalette(p)
		
		self.setWindowTitle("Warning!")
		self.setMinimumSize(QSize(225, 130))
		self.setMaximumSize(QSize(225, 130)) 
		self.resize(225, 130)

		layout = QVBoxLayout()
		
		label = QLabel("The Root Node Is Limited To One Child", self)
		label.setStyleSheet("color: white")
		label.setAlignment(Qt.AlignCenter)
		label.setWordWrap(True)

		closeButton = QPushButton('Close', self)
		closeButton.clicked.connect(lambda : self.close())
		
		layout.addWidget(label)
		layout.addWidget(closeButton)
		
		self.setLayout(layout)
		
class SettingsWindow(QDialog):

	autoOrg = True
	
	def __init__(self, window):
		super().__init__()

		self.setWindowModality(Qt.ApplicationModal)

		self.window = window
		
		p = self.palette()
		p.setColor(self.backgroundRole(), QColor(0x3D, 0x3D, 0x3D))
		self.setPalette(p)
		
		self.setWindowTitle("Settings")
		self.setMinimumSize(QSize(225, 130))
		self.setMaximumSize(QSize(225, 130)) 
		self.resize(225, 130)

		layout = QVBoxLayout()
		
		autoOrganizeToggleButton = QPushButton('Auto-Organize: On', self)
		autoOrganizeToggleButton.setStyleSheet("background-color : green")
		autoOrganizeToggleButton.setCheckable(True)
		autoOrganizeToggleButton.clicked.connect(lambda : self.toggleButtonAppearance(autoOrganizeToggleButton))
		
		changeNodeColorButton = QPushButton('Change Node Color')
		changeNodeColorButton.clicked.connect(lambda : self.changeColor("node"))
		
		changeBackgroundColorButton = QPushButton('Chance Background Color')
		changeBackgroundColorButton.clicked.connect(lambda : self.changeColor("background"))		
		
		closeButton = QPushButton('Close', self)
		closeButton.clicked.connect(lambda : self.close())
		
		layout.addWidget(autoOrganizeToggleButton)
		layout.addWidget(changeNodeColorButton)
		layout.addWidget(changeBackgroundColorButton)
		layout.addWidget(closeButton)
		
		self.setLayout(layout)
		
	def toggleButtonAppearance(self, button):
		if button.isChecked():
			button.setText('Auto-Organize: Off')
			button.setStyleSheet("background-color : red")
			self.autoOrg = False
		else:
			button.setText('Auto-Organize: On')
			button.setStyleSheet("background-color : green")
			self.autoOrg = True
			
	def changeColor(self, choice):
		color = QColorDialog.getColor()
		
if __name__ == "__main__":
	rospy.init_node('htt_viz')
	app = QtWidgets.QApplication(sys.argv)
	mainWin = MainWindow()
	mainWin.show()
	sys.exit( app.exec_() )
	rospy.spin()
